# 二期.md


## 项目背景

同花顺资讯（新闻）项目反馈说网页打开很慢，性能指标 90 分位的 domready 是 2000ms 左右，window.onload 时间更长。经过本机测试发现网页内容呈现出来之前有一段白屏时间，性能确实不好。本机 4 核 8g 内存，domready 都要 1000 毫秒，而 widnow.onload 则在 2000ms 以上。而且这些数据都是在命中网络资源缓存的情况下测得的。而用户的手机性能千差万别，平均下来时间比我本机长也不足为奇。

## 项目结构分析

该项目为后端 php 生成的 vue 框架的单页面项目，网页引用的 js 资源在 20 个以上，其中包含组件库两个，vue 源码库，埋点库等，这些 js 资源加载与执行才能渲染出页面，网页慢的原因就在这里：网络资源多导致网络请求的时间变长在加上解析资源执行 js 脚本的时间，js 脚本的执行会阻塞后续渲染，而网页的内容完全依靠 js 的执行渲染出来的，所以在 vue 渲染出页面之前都是白屏的状态。

## 性能分析关键指标 Performance

名词解释 https://web.dev/

`FCP`：Fisrt Contentful Paint ，首次有内容渲染的时间

`LCP`：Largest Contentful Paint，最大内容渲染时间

`TTI` ： Time To Interactive，可交互的时间

`TBT` : Total Block Time ，总阻塞时间，从 FCP 到 TTI 每个任务阻塞时间的总和

`CLS` : Cumulative Layout Shift，累计布局偏移

`Speed Index` : 首屏展现平均值

`TTFB` :Time To First Byte，服务端响应时间

## performance.timing

1.connectEnd
navigationStart:上一个文档卸载的时间
unloadEventStart unload 时间抛出时的时间
unloadEventEnd unload 事件处理完成时的时间戳
redirectStart HTTP 重定向开始的时间
redirectEnd HTTP 重地向完成
fetchStart 浏览器准备好使用 HTTP 请求来获取文档的时间
domainLookupStart 域名查询开始的时间
connectStart HTTP 请求开始向服务器发送时的时间
connectEnd 浏览器与服务器之间的链接建立的时间 链接建立指的是所有握手和认证过程全部结束
secureConnectionStart 浏览器与服务器开始安全链接的握手时的时间
requestStart 浏览器向服务器发出 HTTP 请求时
responceStart 浏览器从服务器收到第一个字节是的时间
responceEnd 浏览器从服务器收到最后一个字节时的时间
domLoading DOM 结构开始解析时，Document.readyState 属性变为“loading”
domInteractive DOM 结束解析 开始加载内嵌资源换 Document.readyState 属性变为“interactive”
domContentLoadedEventStart 所有需要被执行的脚本已经被解析的时间 触发 DOMContentLoaded
domContentLoadedEventEnd 当所有需要立即执行的脚本已经执行完的时间
domComplete 返回当前文档解析完成 Document.readyState 变为“complete”
loadEventStart load 事件被发送时的时间
loadEventEnd 返回 load 事件结束

## 优化思路

网页渲染的过程可以分为资源请求阶段和网页渲染阶段。优化的方法也是在这两个方向进行优化。
网页渲染过程
浏览器发出请求 => DNS 解析 => 建立 TCP 链接 => 发送 HTTP 请求 => 服务器响应 =>下载文档 => 解析 DOM 树，cssOM 树 => 树合并 => 计算与渲染
`下载文档`之前的过程为`网络阶段`，其后为`渲染阶段`

### 常规优化方案

只要在网站搜索网页性能优化基本都能出现以下几点：

1.  网页资源开启缓存
2.  域名预解析
3.  移除未使用的 js 和 css
4.  压缩代码
5.  压缩图片及图片懒加载
6.  异步加载，优先保证主体加载完成
7.  js 放在 body 后面，防止阻塞渲染

但是对于实际的项目，情况要复杂的多。按照前面的优化思路，前 5 点实际上只是在`网络阶段`进行优化，包括移除未使用的 js 和 css，压缩代码，这都是在减少网络资源的体积，进而减少网络请求的时间，这些优化当然是必要的并且在实际效果也很明显。
但是如今的前端项目，大部分项目都有良好的缓存策略，静态资源都是来自本地缓存，现在甚至流行借助客户端的能力做网页离线化，直接将资源放在客户端，网页请求资源时，客户端直接返回相应的资源，这也是在网络阶段进行优化。基于此，网络阶段如果已经做到了极限，但如果我们的渲染还是慢，如何提升性能呢。

### 渲染阶段性能优化

在渲染阶段优化性能主要是以下方面：

1. 删除代码
2. js 放在 body 后面
3. 保证主要内容优先加载
4. 结合客户端进行优化
5. 服务端渲染或预渲染

对于第一点，首先删除 js 风险很高，而且对于老的项目你不知道哪些代码是可以安全的删除的，其次删除一些代码对于整个网页的渲染影响很小的，除非是非常消耗性能的代码被重写了，但是这样的代码很少。对于一个长久运行的项目经过很多人的维护，每次有改动基本都是新加逻辑，很少会去移除逻辑，所以代码会越来越臃肿，这就是为什么老项目被称为“屎山”的原因。

对于第二点很多地方都有所提及，原因是 js 的下载和执行会阻塞渲染过程。但是对于一个近代项目而言，大部分网页内容都是通过 js 渲染出来的，无论是 React 项目还是 Vue 项目，没有 render 之前网页基本都是白屏状态，所以 js 资源在 body 前面还是后面对于整个渲染过程是没有影响的。

所以，对于完全依靠 React 或者 Vue 渲染出来的网页，到 render 成功之前的这段时间都是白屏的。减少白屏时间的主要手段还是第三点，尽量让渲染提前。

让渲染提前其中一个思路是将与渲染无关的脚本延迟执行，至少等到 render 完成之具体做法是将 js 资源分为两类，一类是 render 过程中必不可少的资源，一类是 render 过程无关的资源。将第一类资源放在 render 之前，将第二类资源放在 render 过程之后。但如何确定哪些是与 render 无关的资源呢，最简单的方法就是一次删除一个资源，看网页能否正常渲染出来，或者通过控制台看是否有报错。如果有报错或者不能正常的渲染出来，那么它就是属于第一类资源。如果在某些情况下，某个资源又是必须的，比如某些页面包含 video，video 又依赖于 video.js,那么可以判断网页包含 video 则 video.js 是属于第一类资源，否则则为第二类资源。

让渲染提前的另外一个思路让正文提前渲染出来。比如叫正文的渲染优先级提到最高。具体做法是可以通过 v-if 控制其他内容的渲染，等到正文渲染完毕，然后将 v-if 的值设为 true。这种做法可以让用户觉得渲染变快了，实际上性能参数并没有变化。还有一种做法就是结合服务端渲染或者与渲染，将服务端渲染成功的 HTML 直接作为 html 的节点，待客户端渲染完毕后，将这部分内容隐藏，这样的做法优点是一打开页面就看到了完成的 HTML 文档，给人一种非常快的感觉，相当于是一种高级的鱼骨图。但是这种优化的效果常规的性能参数无法体现，需要通过 LCP 这种复杂的性能指标来体现出来，但是很遗憾的是 LCP 在移动端兼容性非常差。

最后一种复杂的做法就是找出 js 渲染的瓶颈，做好 js 代码分割，通过异步的方式加载 js。这就需要对项目的绝对熟悉，抽离出哪些业务可以分离出来异步渲染。这个和上面的区别就是组件库的大小变小，并且在主体渲染完成之前必须执行的代码变少，较少 js 的执行和解析然后减少白屏时间。

## 资讯项目实践

综合分析发现最适合资讯项目的优化方式为`异步加载网页内容`和`网页预渲染`

### 异步加载网页内容

1. 经过第一期性能优化，DomReady90 分位时间由 2000ms 下降到 1600ms，但依旧很慢。一期也也未涉及到核心代码的优化，二期优化的重点在于优化组件库。
2. 资讯网页打开时会有长时间的白屏，经过分析是由于在渲染网页之前有很多 js 资源阻塞的 Vue 的渲染，优化的核心思想在于减少渲染之前 js 资源的执行，尽可能将渲染提前。
3. 经过一期优化，渲染之前必须引入的 js 有 10 余个，其中耗时较久的有 baselib，在本地测试大概需要 60ms，thspostlib 组件库耗时 400ms，并且发现 thspostlib 压缩后大小为 900 多 kb，是属于相当大的资源。优化的重点在于优化 thspostlib

### 组件库代码优化

thspostlib 组件库中包含组件 30 个，优化的思想为保证首屏的相关组件优先渲染，然后再按需渲染其他组件

1. 将组件分为首页渲染相关的组件和与首页渲染无关的组件
2. 首页相关的组件有 ths-container,ths-title,ths-voice,ths-creative,ths-content，将这 5 个组件打包，同步加载与渲染
3. 其他组件通过 vue 提供的按需组件配合 webpack 打包的方式引入，减少首屏资源的体积。为避免打包出来的 js 文件过多，采用通过以 ths-navigation 为入口，在此组件中引入其他组件，最后打出来的包只有两个 js 文件

### 方案存的风险

主要有以下两个风险

1. 异步组件加载晚于其他组件，是否存在生命周期的问题；
2. 以前组件全量引入并且导出为`components`属性，现在组件数量少于以前的组件，是否存在别的项目引用`components`中异步引入的组件。
  

#### 结果分析

将组件分开打包后，thspostlib 的体积由 900 多 Kb 减少到 400 多 KB，在本地 LCP 由 800ms 减少到 600ms，并且在低端机上网页白屏时间明显减少，取得了明显效果，同时网页其他内容依然正常渲染。

#### 存在问题

1. 正文组件 ths-content 包含 Video 组件与 Audio 组件，绝大部分网页都没有用到这个组件，并且这两个组件引用了 hxm-ui 库，体积较大（约 100kb），理论上应该按需导入，但在实践过程中发现，这两个组件如果按需导入了会导致其他组件无法正常导入，此问题在一个普通的 vue-demo 中也重现，所以推测为 vue 的 bug。解决办法是将这两个组件放在最后面异步加载
```
// vue.js
  var res = Object.create(parentVal || null);
```
2. Video组件注册监听了`content_loaded`事件，但是由于Video组件是异步加载的，所以这个事件永远也不会触发，因此将处理函数在Video挂载后立即触发 （风险1）
3.  检查所有引用组件库的代码发现 sns 中有使用导出的`components`属性中的`risk-content`组件,所以把`risk-content`也加入到首屏组件中（风险1）


预渲染方案（理想方案）
资讯网页存在发布平台，是否在生成网页的时候就将网页的内容就渲染到网页的DOM中？主要做法是在后端（目前是php）生成网页时执行一次渲染，然后将网页内容渲染到页面中，这样网页端拿到的网页就是已经包含网站内容的文档了，然后再执行js渲染增加交互。这是一种伪SSR的思想

生成的流程为：

资讯生成平台保存网页 => 请求网页渲染服务 => 使用puppteer渲染页面并返回dom内容 => 资讯网页将内容保存到html文档中dom1中 => 将vue根节点容器dom2的display属性设为none => 保存网页到服务器中



客户端打开的流程为：

打开资讯页 => 直接渲染dom1 => 执行js将vue挂载到dom2 => vue渲染完毕隐藏dom1，显示dom2 => 网页渲染完毕

各种优化方案结果对比
各种效果如下图所示 从左到右依次为未优化，第一期优化，第二期优化（异步加载），预渲染方案



总结
资讯优化项目持续两个多月，纯前端能做的优化基本到了极限，项目本身依赖错综复杂，已经很难拆分。后续只能借助客户端的能力做离线化或者模板方案，

或者使用预渲染方案，如果能做预渲染则能达到最好的视觉效果。

Some content has been disabled in this document

