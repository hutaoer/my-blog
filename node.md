# node
## Node 里的模块是什么？
* 一个文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C/C++ 扩展。
* require 用来加载代码，而 exports 和 module.exports 则用来导出代码。
* module.exports 初始值为一个空对象 {}
* exports 是指向的 module.exports 的引用
* require() 返回的是 module.exports 而不是 exports
* 于是就有了 exports => {} <=module.exports.这2个exports 其实是没有直接关系的,唯一的关系是: 他们初始都指向同一个空对象{}; 如果其中一个不指向做个空对象了, 那么他们的关系就没有了.
```js
function Module(id, parent) 
{ this.id = id; this.exports = {}; this.parent = parent; this.filename = null; this.loaded = false; this.children = [];}
module.exports = Module; var module = new Module(filename, parent);
```

## require 的模块加载机制
* 当我们require某个模块时，并不是只拿他的module.exports，而是会从头开始运行这个文件.
* 计算模块绝对路径；
* 如果缓存中有该模块，则从缓存中取出该模块；
* 按优先级依次寻找并编译执行模块，将模块推入缓存（require.cache）中；
* 输出模块的 exports 属性

## node 内存泄漏和解决方案
* 1. 全局变量：全局变量挂在 root 对象上，不会被清除掉； 2. 闭包：如果闭包未释放，就会导致内存泄露； 3. 事件监听：对同一个事件重复监听，忘记移除（removeListener），将造 成内存泄露。4. 手动清除定时器，5. 清除DOM引用。
* process.memoryUsage
* heapTotal 和 heapUsed 代表 V8 的内存使用情况。
* heapTotal：表示V8当前申请到的堆内存总大小。
* heapUsed：表示当前内存使用量。
* external：表示V8内部的C++对象所占用的内存。
* rss(resident set size)：表示驻留集大小，是给这个node进程分配了多少物理内存，这些物理内存中包含`堆，栈和代码片段`。`对象，闭包等存于堆内存`，变量存于`栈内存`，实际的JavaScript源代码存于代码段内存。

## 在 Node 中两个模块互相引用会发生什 么？
*  AB 模块互相引用，此时运行 A 模块的话，先运行的 A 模块将会被 缓存，但是此时缓存的是一个未执行完毕的 A 模块.
* 而 A 模块中引入的 B 模块将会被完整加载并且正常使用，
* 而 B 模块中调用的 A 模块将会是个默认的 空对象（module.exports 的默认值），不具备 A 模块的任何功能。
* 循环引用中，先加载的模块是一个空对象。

## Node 如何实现热更新
* Node 中有一个 api 是 require.cache，如果这个对象中的引用被清楚后，下次 再调用就会重新加载，这个机制可以用来热加载更新的模块。
* 用 fs.watchFile 监听文件的更改，文件更改后调用 clearCache 传入对应 的模块名即可。

## 为什么 Node.js 不给每一个.js 文件以独立 的上下文来避免作用域被污染?
* 模块中的全局变量可以访问，也可以被其他模块访问，要避免这种情况。
* 模块正常情况下对作用域不会造成污染（模块函数内执行）
* 由于只有在 .js 文件中没有声明过才会被挂载在global对象上，每个模块就是独立的作用域，所以要避免上下文污染，只需要在写代码的时候添加`use strict`：

## Node 更适合处理 I/O 密集型任务还是 CPU 密集型任务？为什么？
* Node 更适合处理 I/O 密集型的任务。因为 Node 的 I/O 密集型任务可以异 步调用，利用事件循环的处理能力，资源占用极少，并且事件循环能力避开了多 线程的调用，在调用方面是单线程，内部处理其实是多线程的。
* 并且由于 Javascript 是单线程的原因，Node 不适合处理 CPU 密集型的任务，CPU 密集型的任务会导致 CPU 时间片不能释放，使得后续 I/O 无法发起，从 而造成阻塞。

## Node 垃圾回收
* 脚本引擎是 Chrome 的 V8 引擎，所以垃圾回收机制也属 于 V8 的内部垃圾回收机制。
* 默认情况下，V8引擎在64位系统下最多只能使用约1.4GB的内存，在32位系统下最多只能使用约0.7GB的内存，在这样的限制下，必然会导致在node中无法直接操作大内存对象。
* 试想如果JS是多线程的，一个线程在删除DOM元素的同时，另一个线程对该元素进行修改操作，那么必然会导致复杂的同步问题。
* Web Worker标准，其作用就是为JS创造多线程环境，允许主线程创建Worker线程，将一些任务分配给后者运行。在主线程运行的同时，Worker在后台运行，两者互不干扰。等到Worker线程完成计算任务，再把结果返回给主线程。Web Worker不是JS的一部分，而是通过JS访问的浏览器特性，其虽然创造了一个多线程的执行环境，但是子线程完全受主线程控制，不能访问浏览器特定的API，例如操作DOM，因此这个新标准并没有改变JS单线程的本质。
* Scavenge算法的垃圾回收过程主要就是将存活对象在From空间和To空间之间进行复制。
* V8的垃圾回收策略主要是基于分代式垃圾回收机制，其根据对象的存活时间将内存的垃圾回收进行不同的分代，然后对不同的分代采用不同的垃圾回收算法。
* 对于新生代的内存采取的是将内存区一分为二，将存活的对象从一个区复制到另 一个区，然后对原有的区进行内存释放，反复如此。当一个对象经过多次复制依 然存活时，这个较长生命周期的对象会被移动到老生代中。 对于老生代的垃圾回收采用的是`标记清除算法`，遍历所有对象并标记仍然存在的 对象，然后在清除阶段将没有标记的对象进行清除，最后将清除后的空间进行内存释放。
* 新生代(new_space)：大多数的对象开始都会被分配在这里，这个区域相对较小但是垃圾回收特别频繁，该区域被分为两半，一半用来分配内存，另一半用于在垃圾回收时将需要保留的对象复制过来。
* 老生代：新生代中的对象在存活一段时间后就会被转移到老生代内存区，相对于新生代该内存区域的垃圾回收频率较低。而是采用新的算法Mark-Sweep(标记清除)和Mark-Compact(标记整理)来进行管理。

## 异步IO
* Node 便会创建一个类似于 while(true) 的循环，每执行一次循 环体的过程成为 Tick。每个 Tick 的过程就是查看是否有事件待处理，如果有， 就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行它们。然后 进入下个循环，如果不再有事件处理，就退出进程。（每一次 Tick 都会把观察 者中可执行的事件执行完毕后，再进行下一次的 Tick）
* 事件循环是一个典型的生产者/消费者模型。异步 I/O、网络请求等则是事件的生 产者，生产出的事件被传递到对应的观察者，事件循环从观察者取出事件并处理
* 发起异步调用 2. 封装异步执行对象，设置回调函数和参数 3. 将异步执行对象推入线程池（主线程继续往下执行） 4. （一段时间后）异步执行对象执行完毕，将执行后的结果连同线程一起交 还给主线程； 5. 主线程的 Tick 检测到有执行完成的异步任务，将执行对象取出，执行对 应的回调函数； 6. 完成
* 遇到像上面那种需要长时间等待的I/O操作，我们就将它作为一个异步任务分发出去，等待它执行完毕后再通知我们。
* 当这些异步任务在对应的线程中处理完成得到结果后，这些任务的回调就会被加入到callback queue队列当中。另一方面，JS主线程的执行栈中一旦所有同步代码执行完毕后就会开始不停的检测callback queue，只要队列中存在任务，就会被提取到执行栈中执行。
* 其中JS主线程从callback queue中不断读取事件到执行栈中执行的这种循环的过程又被称之为EventLoop，即事件循环。

### node 中的 eventloop
* node中的事件环和浏览器中的是不一样的，node的事件环分为六个阶段，每个阶段都一有一个callbcak queue，只有当一个阶段的queue清理干净后才会进入到下一个阶段。
timer(计时器)，执行setTimeout以及setInterval的回调
I/O callbcacks，处理网络、流、tcp的callbcak以及错误
idle,prepare node内部使用
poll(轮询)，会等待I/O执行直到得到cb
check，处理setImmediate回调
close callbcaks，处理关闭的回调例如socke.on('close')

### 宏任务和微任务
* 一种称之为macro task，即宏任务，像setTimeout、I/O读写、AJAX这类耗时灰常长的。
* 另外一种则称之为micro task，即微任务，例如`nextTick、promise`。（即使定时器的delayt时间设置为0，也是宏任务，会在本轮的微任务执行完毕后再执行）
* 宏任务和微任务的区别在于，微任务是会被加入本轮循环的，而宏任务都是在次轮循环中被执行。
* 本轮循环是指什么呢？JS主线程会从任务队列中提取任务到执行栈中执行，每一次执行都可能会再产生一个新的任务，对于这些任务来说这次执行到下一次从任务队列中提取新的任务到执行栈之前就是这些新生任务的本轮。

## 浏览器模型
* 其中渲染引擎内部有三个线程是我们注重需要关注的，js线程和ui线程是互斥的。
* Networking：用于网络调用，比如HTTP请求
* Javascript解释器：用于解析和执行Javascript代码
* UI Backend

## 进程的当前工作目录是什么？有什么作 用？
* 进程的当前工作目录默认值是当前进程启动的目录，通过 process.cwd() 可以获 取当前工作目录（current working directory），文件操作等使用相对路径时会 相对当前工作目录来获取文件。

## IPC
* 进程间通信。（Inner-Process Communication
* Node 在启动子进程的时候，主进程先建立 IPC 通道，然后将 IPC 通道的 fd （文件描述符）通过环境变量（NODE_CHANNEL_FD）的方式传递给子进程， 然后子进程通过 fd 与 父进程建立 IPC 连接。

##  什么是守护进程？Node 如何实现守护进 程？
* 守护进程是不依赖终端（tty）的进程，不会因为用户退出终端而停止运行的进程。
* 有的使用supervise，有的使用pm2做进程守护，forever、nohup（比较简单）、StrongLoop-PM

## 介绍buffer
* Buffer 是 Node 中用于处理二进制数据的类，其中与 IO 相关的操作（网络/ 文件等）均基于 Buffer。Buffer 类的实例非常类似于整数数组，但其大小是固 定不变的，并且其内存在 V8 堆栈外分配原始内存空间。Buffer 类的实例创建 之后，其所占用的内存大小就不能再进行调整。

## 介绍 stream
* 流（stream）是 Node 中处理流式数据的抽象接口，stream 模块用于构建实现 了流接口的对象。
* 流可以是可读的、可写的、或者可读可写的，所有的流都是 EventEmitter 的实例。

## hosts 文件
* hosts 文件是个没有扩展名的系统文件，其作用就是将网址域名和其对应的 IP 地址建立一个关联“数据库”，当用户在浏览器中输入一个 url 时，系统会首先自 动从 hosts 文件中寻找对应的 IP 地址。

## 消息队列
* 

## koa
* koa实现原理：https://zhuanlan.zhihu.com/p/141890366

### 中间件
* 引入的中间件都是在 use 方法中调用，由此我们可以分析出每一个 Koa 的中间件都是返回一个 async 函数的。
* 使用中间件的时候，先 use，中间件return一个异步方法，通过 next，来交给其他中间件处理。一层层的。
* use 中间件以后，就可以使用对应的中间件的功能。
* next是koa传入的将要处理的下一个异步函数。
* 中间件的执行很像一个洋葱，但并不是一层一层的执行，而是以next为分界，先执行本层中next以前的部分，当下一层中间件执行完后，再执行本层next以后的部分。
* 在 Express 框架中，路由是被内置在了框架内部，而 Koa 中没有内置，是使用 koa-router 中间件来实现的，
* 异步递归比同步递归的好处是可以被打断，如果中间有一些优先级更高的微任务，那么可以先执行别的微任务















































